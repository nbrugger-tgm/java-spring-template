import java.util.stream.Collectors

apply plugin: 'java'
apply plugin: 'org.sonarqube'
apply plugin: 'jacoco'

println "Configure ${project.name}"

sourceSets {
    archTest {
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}
configurations {
    archTestImplementation.extendsFrom implementation
    archTestRuntimeOnly.extendsFrom runtimeOnly
}
dependencies {
    compileOnly 'org.junit.jupiter:junit-jupiter-api:5.7.2'

    testImplementation 'org.junit.jupiter:junit-jupiter:5.7.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.2'
    testRuntimeOnly "org.junit.platform:junit-platform-commons:1.8.+"
    testImplementation "org.mockito:mockito-core:3.+"
    testImplementation 'org.mockito:mockito-junit-jupiter:4.1.0'
    archTestImplementation 'com.tngtech.archunit:archunit-junit5:0.22.0'
}

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
    withJavadocJar()
    withSourcesJar()
}
repositories {
    mavenCentral()
}


task archTest(type: Test) {
    description = 'Runs architectural tests.'
    group = 'verification'

    testClassesDirs = sourceSets.archTest.output.classesDirs
    classpath = sourceSets.archTest.runtimeClasspath
    useJUnitPlatform()
}
task unitTest(type: Test) {
    description = 'Runs unit tests.'
    group = 'verification'

    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    useJUnitPlatform()
}
sonarqube {
    properties {
        property 'sonar.coverage.jacoco.xmlReportPaths', "$projectDir/build/reports/jacoco/coverage.xml"
    }
}


subprojects {
    apply from: "${rootDir}/modules/submodule.gradle"
}

tasks.withType(Javadoc) {
    failOnError = false
}

tasks.create("testJar", Jar.class) {
    from sourceSets.test.output
}
def jacocoFiles = ()->project.tasks.withType(Test)
        .stream()
        .filter(tt -> tt.candidateClassFiles.files.stream().anyMatch(f -> f.exists() && f.isFile()))
        .map(t -> t.name)
        .map(n -> file("$buildDir/jacoco/${n}.exec"))
        .toArray(File[]::new);

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    afterEvaluate {
        executionData.setFrom(jacocoFiles())
    }
    violationRules {
        rule {
            limit {
                minimum = project.ext.minCoverage
            }
        }
    }
}

tasks.jacocoTestReport {
    // tests are required to run before generating the report
    dependsOn archTest
    dependsOn unitTest

    afterEvaluate {
        executionData.setFrom(jacocoFiles())
    }
    reports {
        xml.enabled true
        xml.destination file("$buildDir/reports/jacoco/coverage.xml")
        html.enabled true
        html.destination file("$buildDir/reports/jacoco/html")
        csv.enabled false
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it,
                    exclude: ['**/entities/**', '**/models/**'])
        }))
    }
}
tasks.check {
    finalizedBy tasks.jacocoTestCoverageVerification
}
jacoco {
    toolVersion = "0.8.5"
}
tasks.test {
    // Use junit platform for unit tests
    useJUnitPlatform()
    finalizedBy tasks.jacocoTestReport // report is always generated after tests run
}
javadocJar.enabled = false
sourcesJar.enabled = false